// Generated by CoffeeScript 1.7.1
var _;

_ = require('lodash');

module.exports = function(injectors, injector, prop, key) {
  var args, construct, create, e, filter, get, i, l, match, overrides, r, singleton, tmp, wrap;
  filter = function(instance) {
    return instance;
  };
  wrap = function(instance) {
    return function() {
      return instance;
    };
  };
  get = function(instance) {
    return function() {
      var k, r, v;
      for (k in injectors) {
        v = injectors[k];
        if (instance.substring(0, k.length).replace('.', '-') === k) {
          r = instance.substring(k.length + 1);
          if (r.length > 0) {
            return v.get(r);
          }
        }
      }
      return injector.get(instance);
    };
  };
  construct = function(key, instance, args) {
    return function() {
      injector.register(key, construct(key, instance, args));
      return instance.construct(args);
    };
  };
  create = function(key, instance, args) {
    return function() {
      injector.register(key, create(key, instance, args));
      return injector.get(instance, args);
    };
  };
  if (_.isArray(prop) && prop.length > 0 && _.isFunction(prop[prop.length - 1])) {
    if (prop.length > 1) {
      tmp = prop.splice(0, prop.length - 1);
      prop = prop[0];
      prop.inject = tmp;
    } else {
      prop = prop[0];
    }
  }
  if (prop.singleton != null) {
    singleton = prop.singleton;
  } else {
    singleton = true;
  }
  if (_.isFunction(prop)) {
    if ((prop.inject != null) || prop.name.length > 0) {
      overrides = {};
      match = prop.toString().match(/function.*?\(([\s\S]*?)\)/);
      if (match == null) {
        throw new Error("could not parse function arguments: " + (prop != null ? prop.toString() : void 0));
      }
      args = match[1].split(",").filter(filter).map(function(str) {
        return str.trim();
      });
      if (prop.inject == null) {
        prop.inject = args;
      }
      if (prop.name.length > 0) {
        prop.construct = function(a) {
          var fconstructor, nconstructor;
          fconstructor = prop;
          nconstructor = function() {
            return fconstructor.apply(this, a);
          };
          nconstructor.prototype = fconstructor.prototype;
          return new nconstructor();
        };
      }
      for (i in args) {
        r = args[i];
        overrides[r] = get(prop.inject[i]);
      }
    }
  }
  if (prop.inject != null) {
    if (key != null) {
      if (prop.name.length > 0) {
        injector.register("__" + key, wrap(prop));
      } else {
        injector.register("__" + key, prop);
      }
      return injector.register(key, function() {
        var e, l, res;
        if (prop.name.length > 0) {
          args = [];
          for (l in overrides) {
            e = overrides[l];
            args.push(e());
          }
          if (singleton) {
            res = injector.get("__" + key).construct(args);
            injector.register(key, wrap(res));
          } else {
            res = construct(key, injector.get("__" + key), args)();
          }
        } else {
          for (l in overrides) {
            e = overrides[l];
            overrides[l] = e();
          }
          if (singleton) {
            res = injector.get("__" + key, overrides);
            injector.register(key, wrap(res));
          } else {
            res = create(key, "__" + key, overrides)();
          }
        }
        return res;
      });
    } else {
      if (prop.name.length > 0) {
        args = [];
        for (l in overrides) {
          e = overrides[l];
          args.push(e());
        }
        return prop.construct(args);
      } else {
        for (l in overrides) {
          e = overrides[l];
          overrides[l] = e();
        }
        return injector.resolve(overrides, prop);
      }
    }
  } else {
    if (key != null) {
      if (singleton) {
        return injector.register(key, prop);
      } else {
        injector.register("__" + key, prop);
        return injector.register(key, function() {
          return create(key, "__" + key, {})();
        });
      }
    } else {
      return injector.resolve(prop);
    }
  }
};
